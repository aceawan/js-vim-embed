{
  "name": "js-vim",
  "version": "0.0.10",
  "description": "A JavaScript implementation of the vim text editor",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "commander": "1.1.1",
    "diff_match_patch": "0.1.1",
    "js-vim-command": "*"
  },
  "devDependencies": {
    "chai": "1.6.1"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/itsjoesullivan/vim.git"
  },
  "keywords": [
    "vim"
  ],
  "author": {
    "name": "Joe Sullivan",
    "email": "itsjoesullivan@gmail.com"
  },
  "license": "MIT",
  "gitHead": "7250b5b4cbcc584454811012bcad5254162f7f0a",
  "readmeFilename": "README.md",
  "readme": "#Vim(for Chrome)\n\nVim\nfor Chrome is a project to bring the vim editor to Google Chrome as an app.\n\n##Commands\n\nThe crucial bit, at least with respect to central functionality, is how commands are executed and defined.\n\nTo move to insert mode:\n\n  vim.exec('i');\n\nTo type hello:\n\n\tvim.exec(['h', 'e', 'l', 'l', 'o']);\n\nObviously, this provides a simple way to route keystrokes into the application.But it also facilitates creating new commands:\n\nCapital \"O\"\nmight be defined like:\n\n\tvim.exec(['k', 'o']);\n\n\n##Extensibility\n\nThe actual extension API is like:\n\n\tvim.extend({\n\t\t'insert': { //name of mode you are extending\n\t\t\t'O': function() {\n\t\t\t\tvim.exec(['k', 'o']);\n\t\t\t}\n\t\t},\n\t\ton: { //event-based actions\n\t\t\t'insert': function() { //event fired by vim on switch to insert\n\t\t\t\tvim.notify('-- INSERT --');\n\t\t\t}\n\t\t}\n\t});\n\nA little more dry:\n\n###Extension object:\n\n\textensionObject = {\n\t\t{\n\t\t\tmode: {\n\t\t\t \t{\n\t\t\t\t'command': function(value) {\n\t\t\t\t\t//run when that command is called in that mode\n\t\t\t\t},\n\t\t\t...\n\t\t},\n\t\ton: {\n\t\t\t'eventName': function(subject) { ... };\n\t\t\t...\n\t\t}\n\t};\n\n- __mode__ is a string, but can be any mode. \n- __command__ is a string, BUT will be executed as a regular expression if a literal match is not found. The command function is given the command value in any case.\n\n###What about syntax + highlighting ?\n\nMaybe the question is: how does this structure allow for syntax formatting and highlighting ?\n\nI __think__ that the answer is pretty straightforward : create a listener for the \"stroke\" event(doesn 't exist), which will get passed the actual line that changed. Check the line for your keywords, then when you find them draw out the __element__ associated with each character and add a class ('function ') if the keyword is 'function ' for later handling by a stylesheet. That seems about as easy/efficient as it _could_ be, though obviously that would then be exposed in a more friendly way.\n\n##Status\n\nJust revisiting this (spring 2013) since starting it last winter. Need to evaluate whether (1) the architecture will actually scale to the needs of vim (hunch: yes) and (2) need to find a better solution for rendering. The backbone paradigm, I think, breaks down with this. We end up with a trillion 'models' for characters when fundamentally we're just trying to map a string of text to the screen with some extra meta information. So that needs some thought, and a rewrite based on those conclusions.\n",
  "_id": "js-vim@0.0.10",
  "_from": "js-vim@0.0.10",
  "dist": {
    "shasum": "7bb88e274cc8258e69439e80fb77cce7013d48c8"
  },
  "_resolved": "https://registry.npmjs.org/js-vim/-/js-vim-0.0.10.tgz"
}
